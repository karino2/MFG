# 改行の扱いについて

- Created: 2024-12-21
- Updated: 2025-09-27

改行はスペースとして動いて欲しい事が多い。
例えば

```
def ts |x,
        y|
{
  x+y
}
```

のように、引数のところなどに自由に改行を挟んでも構わない方が嬉しい。

だがMFGには行末にセミコロンが無い。
しかもreturnも無く、最後の式がreturnの値となる。

だから以下のようなコードがあった時に

```
let a = 5
-3
```

これが `let a = 5 - 3`　と解釈されるのは嬉しくない。

そこでMFGでは、式は何かの途中で無い限りは改行を区切りとして、
式以外は全て改行はスペースとして扱う事にしている。

## 式以外の空白

テンソル定義、例えば以下のようなものは、

```
def ts2 by reduce<hist>.accumulate(init=1, dim=0) |i, col, val, accm | { accm + val }
```

accm+val以外は全て改行は空白と同様に扱われる。

## 式の改行による区切り

式ではEOLは区切りとみなす。つまり、前述のような以下のケースは、

```
let a = 5
- 3
```

`let a = 5` と `-3` と別々に解釈される。

何が式なのか、というのは文法的な定義が必要だが、感覚的にはletの右辺に来るもの、と思えば良い。
（BinOp及びそれになりうる何か、というのがより厳密な定義となる）

## 式が不完全な時の改行は空白

例えば以下のように、中置演算子で行が終わっている場合などは、

```
let a = 5 -
3
```

改行は空白として扱われて、これは `let a = 5 - 3` と解釈される。

## 式の途中のバックスラッシュによる改行のエスケープ

式の途中の改行は、バックスラッシュでエスケープ出来る。
以下の式は、

```
let a = 5 \
- 3
```

`let a = 5 - 3` とパースされる。

## パイプライン演算子の例外（MEP 27）

以上のルールの例外として、行頭がパイプライン演算子の時、というのがあります。

[MEP 27: パイプライン演算子だけは次の行に書ける例外とするルール](../MEP/27.md)

以下のコードに関して。

```
input_u8(x, y)
|> to_xyza(...)
```

input_u8の行が閉じカッコで終わっていて、これはExprなので通常のルールではここで式は終わりとみなされます。
ですが「次の行の行頭のトークンがパイプライン演算子の時」だけは例外として、
継続行とみなされます。
処理としては改行がエスケープされたのと同様とみなされます。

つまり以下と同じ意味となります。

```
input_u8(x, y) |> to_xyza(...)
```