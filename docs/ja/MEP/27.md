# MEP 27: パイプライン演算子だけは次の行に書ける例外とするルール

- Created: 2025-09-18
- Status: Supported(v1.0.06)

## モチベーション

やはりパイプライン演算子だけは次の行に書きたい。
改行が式の区切りであるのには十分な理由があるのだが、
パイプライン演算子だけは例外にしたい。

改行が式の区切りである事については[Notes: 改行の扱いについて](../notes/EOLHandling.md)を参照のこと。

## 提案

改行の次のトークンがパイプライン演算子の時だけは、改行を空白として扱いたい。

これまでは以下のように書かないといけなかったのを、

```
input_u8(x, y) |>
to_xyza(...)
```

以下のように書いても良いようにしたい。

```
input_u8(x, y)
|> to_xyza(...)
```

仕様としては、式の中で次のトークンを探す時にEOLを空白とせずトークンとして止める所があるが、
この時に次のトークンを先読みしてパイプ演算子だった時は空白扱いとしてスキップする。

## 検討

なぜこれは問題ないのか？他には問題がないケースがあるがそちらはサポートしなのか？などの議論。

### 対応出来る二項演算子

次の行の最初のトークンを見て、式が続いているか区切って別の式なのかが曖昧なのは、マイナス記号だけである。

マイナスな単項演算子が存在するので、それが単項演算子なのか中置の二項演算子なのかが区別出来ない。
そこでマイナスだけは単項演算子とみなす必要がある。

その理屈でいけばマイナス以外の二項演算子もパイプライン演算子と同様のルールで次の行に書けるように出来る。
だが、`+`も`*`も`/`も次の行に書けるが`-`だけは書けない、というのは混乱を生むので、
二項演算子はすべて書けないとしたい。

`+`は次の行に書きたい事もあるが、これは言語仕様として納得出来る範囲に思う。

ただパイプライン演算子だけはやはり次の行に書きたい。

### パイプライン演算子を特別扱いする理由

パイプライン演算子は絶対に行頭に来ないので、曖昧性がない。
そして一つのトークン先読みで解決出来るので、パフォーマンスへの影響もほぼ無い。

パイプライン演算子は、使っている感覚としても通常の二項演算子とは大きく違う。
これが二項演算子であるのも実装の都合であって、ユーザーとしてはあまり二項演算子という感じはしない。
だからパイプライン演算子が次の行に書けるからといって、`-` も書けると誤解する危険性は少ないと思う。

また、パイプライン演算子が次の行に書けるかどうかは、コードの書き味に大きく影響する。
だからわざわざ特別扱いをする理由もあると思う。

### F#のオフサイドルールの特別扱いとの類似性

F#には、Pythonと似たようなインデントでブロックを表す機能があり、
これをオフサイドルールと呼ぶ。

[F# syntax: indentation and verbosity - F# for fun and profit](https://fsharpforfunandprofit.com/posts/fsharp-syntax/)

このオフサイドルールには二項演算子の例外扱いがあり、パーサーとしてはその処理とだいたい同じような処理になる。
前例があるので文法として破綻しない可能性が高い。