# 型

前: [テンソル](Tensor.md)

MFGでは変数や定数には型があります。
基本的には数値型とそれのタプルのみです。

テンソルやsamplerは型とは別の扱いとなります。

また、タプルの特殊なケースをベクトルとして扱う、という機能もあります。
ここではそうした型に関する話を見ていきます。

## 数値型

MFGの基本となる数値型には、符号無し整数、符号あり整数、浮動小数点数の３つがあり、それぞれu, i, fと呼ばれます。
これにビット数をつけて、i32, u8, f32などと使われます。

fは32のみサポートしています。

iは8, 16, 32をサポートしていますが、
下のハードウェアとしては32ビットとして扱うものも多いため、
あまり小さい型を使うメリットはありません。
基本的にはiはi32を使う事を推奨しています。

また、u32はあまり使わず、整数はなるべくi32を使う事を推奨しています。

例外はu8とu16を色のBGRA成分として使う場合で、この場合はu8とu16を使う事になります。


つまり、数値型は以下が基本となります。

- f32
- i32
- u8とu16 (色成分として)

### 数値のリテラル

`123` などと整数を書くと、これはi32とみなされます。
サイズがいくつでもi32とみなしますし、u8を要求する所に123などと書くと型のミスマッチでエラーとなります。

`123.0` などの小数のリテラルはf32となります。

u32のリテラルとして末尾にuをつける、`123u` というものも存在していますが、
あまり使用は推奨しません。整数はなるべくi32で計算をするようにしましょう。

### 数値型のキャスト

数値型のキャストは、型名のあとにカッコをくくって行います。
型名と同じ関数を呼び出す、と考えても構いません。

例えば以下。

```swift
let a = i32(12.0)
```

このキャストはタプルに対してベクトライズされます。

```swift
let a = i32([12.0, 3u, 1])
```

aはi32のタプルとなります。
ベクトライズに関しては、[式とベクトライズ演算](Expression.md)を参照ください。

## タプル型

タプルは数値を並べたものです。
タプルの要素は別々の型でも構いません。

タプルは大括弧で要素をカンマで区切って作ります。

```swift
let tup = [1, 12.0, 3u]
```

タプルの要素は全て数値型で、現時点ではネストはサポートしていません。

タプルの要素のアクセスにはdestructuringとswizzle演算子、インデックスでのアクセスがあります。

### destructuring

タプルの中身を直接変数に取り出す、destructuringがあります。

```swift
let tup = [1, 12.0, 3u]

# destructuringの例
let [a, b, c] = tup
```

上記の例では、a, b, cという変数が出来ます。型はそれぞれi32, f32, u32となります。

使わない要素に関してはアンダースコアを使う事が出来ます。1番目と3番目の要素だけ使いたい場合は以下のようになります。

```swift
let [a, _, c] = tup
```

### swizzle演算子

タプルはswizzle演算子をサポートしている。

- xyzwの組み合わせのみサポート
- 右辺値のみ（そもそもタプルのmutationは対応してない）
- ベクトルである必要は無い

```swift
let a = [1, 2, 3].xxyy
```

aは`[1, 1, 2, 2]`のタプルとなる。

一つだけ指定した場合はスカラーになる。

### インデックスでのアクセス

destructuringとswizzleがメインであまり使う機会は多くありませんが、
数値のインデックスを指定して1要素だけ取り出す事も出来ます。

ドットのあとに数字で取り出します。0オリジンです。

```swift
let tup = [1, 2, 3, 4, 5, 6]

# 数値インデックスのアクセス、0オリジンなのでaは5になる
let a = tup.4
```

### タプルの型は静的に決まらないといけない

少し細かい話ですが、MFGではタプルの型は静的に決まる必要があります。
要素の個数と、各要素の型がパースの時点で確定していなくてはいけません。
動的に個数や中身が変わる型などはサポートしていません。

## タプルとベクトル

特別な条件を満たしたタプルを、ベクトルと呼びます。

特別な条件とは以下になります。

- 1次元以上、4次元以下
- 全部の要素が同じ数値型

この２つの条件を満たすタプルを、ベクトルと呼びます。

MFGではいくつかの関数はスカラーまたはベクトルのみをサポートしているため、
ある変数がベクトルかどうかが重要になる事があります。

[組み込み関数](BultinFunctions.md)の各関数の項目でベクトルをサポートしているものにはその旨記載がありますが、
具体的には以下の関数がスカラーとベクトルのみサポートしています。

- clamp
- cross（これは3次元ベクトルのみ）
- distance
- dot
- isinf
- isnan
- length
- normalize
- mix
- saturate
- sign
- smoothstep
- step

### vec3とvec4関数

スカラーから3次元ベクトルを作るvec3と、4次元ベクトルを作るvec4という関数があります。

```swift
let fvec = vec3(3.0)
let ivec = vec4(1)
```

複数要素を指定してベクトルを作りたい場合は、これでは無く次のキャストのシンタックスシュガーを用います。

### タプルのキャストのシンタックスシュガー

ベクトルは同じ型で無くてはいけない為、ベクトルを作る手っ取り早い方法としてキャストをする、という事は良くあります。
また、色はu8の4次元ベクトルで扱う事が多いため、
この場合もu8にキャストする必要があります。

タプルのリテラルをキャストしたい事は良くある為、
シンタックスシュガーを提供しています。

具体的には型名のあとのカッコを省いて、直接大括弧を書く事が出来ます。

例えば以下の２つのコードは同じ意味になります。

```swift
u8([0, 0, 0xff, 0xff])
u8[0, 0, 0xff, 0xff]
```

このシンタックスシュガーは、u8のベクトルのリテラルであるかのように読めるようにと導入されました。
リテラルと言いましたが、中は変数でも使えます。

```swift
u8[b, g, r, a]
```

### タプルのsplat演算子

大括弧の中と関数呼び出しのカッコの中には、splat演算子`*`と呼ばれるものを使う事が出来ます。
これはsplat演算子のつけられたタプルを展開したものをそこに書いたかのように振る舞います。

例えば以下です。

```swift

let tup1 = [1, 2, 3]

# [1, 2, 3, 4]になる
let a1 = [*tup1, 4] 
```

tup1を展開したものを並べたかのようになる為、a1は4要素のタプルとなります。

swizzle演算子と組み合わせて、BGRAのBGRだけを処理する場合に良く使われます。

```swift
let col = input_u8(x, y)
let bgr = col.xyz
let a = col.a

let bgr2 = bgr/128
u8[*bgr2, a]
```

